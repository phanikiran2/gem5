// -*- mode:c++ -*-

// Copyright (c) 2009 The University of Edinburgh
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Authors: Timothy M. Jones

////////////////////////////////////////////////////////////////////
//
// The actual Power ISA decoder
// ------------------------------
//
// I've used the Power ISA Book I v2.06 for instruction formats,
// opcode numbers, register names, etc.
//
decode PO default Unknown::unknown() {

    16: decode AA {

        // Conditionally branch relative to PC based on CR and CTR.
        format BranchPCRelCondCtr {
            0: bc({{ NIA = (uint32_t)(CIA + disp); }});
        }

        // Conditionally branch to fixed address based on CR and CTR.
        format BranchNonPCRelCondCtr {
            1: bca({{ NIA = targetAddr; }});
        }
    }

    format IntOp {
        17: sc({{ xc->syscall(R0, &fault); }},
               [ IsSyscall, IsNonSpeculative, IsSerializeAfter ]);
    }

    18: decode AA {

        // Unconditionally branch relative to PC.
        format BranchPCRel {
            0: b({{ NIA = (uint32_t)(CIA + disp); }});
        }

        // Unconditionally branch to fixed address.
        format BranchNonPCRel {
            1: ba({{ NIA = targetAddr; }});
        }
    }

    19: decode XL_XO {

        // Conditionally branch to address in LR based on CR and CTR.
        format BranchLrCondCtr {
           16: bclr({{ NIA = LR & 0xfffffffc; }});
        }

        // Conditionally branch to address in CTR based on CR.
        format BranchCtrCond {
           528: bcctr({{ NIA = CTR & 0xfffffffc; }});
        }

        // Condition register manipulation instructions.
        format CondLogicOp {
            257: crand({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa & crBb);
            }});
            449: cror({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa | crBb);
            }});
            255: crnand({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, !(crBa & crBb));
            }});
            193: crxor({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa ^ crBb);
            }});
            33: crnor({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, !(crBa | crBb));
            }});
            289: creqv({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa == crBb);
            }});
            129: crandc({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa & !crBb);
            }});
            417: crorc({{
                uint32_t crBa = bits(CR, 31 - ba);
                uint32_t crBb = bits(CR, 31 - bb);
                CR = insertBits(CR, 31 - bt, crBa | !crBb);
            }});
        }
        format CondMoveOp {
            0: mcrf({{
                uint32_t crBfa = bits(CR, 31 - bfa*4, 28 - bfa*4);
                CR = insertBits(CR, 31 - bf*4, 28 - bf*4, crBfa);
            }});
        }
        format MiscOp {
            150: isync({{ }}, [ IsSerializeAfter ]);

            default: decode DX_XO {
                format IntDispArithOp {
                    2: addpcis({{ Rt = NIA + (disp << 16); }});
                }
            }
        }
    }

    // There is a large number of instructions that have the same primary
    // opcode (PO) of 31. In this case, the instructions are of different
    // forms. For every form, the XO fields may vary in position and width.
    // The X, XFL, XFX and XL form instructions use bits 21 - 30 and the
    // XO form instructions use bits 22 - 30 as extended opcode (XO). To
    // avoid conflicts, instructions of each form have to be defined under
    // separate decode blocks. However, only a single decode block can be
    // associated with a particular PO and it will recognize only one type
    // of XO field. A solution for associating decode blocks for the other
    // types of XO fields with the same PO is to have the other blocks as
    // nested default cases.
    31: decode X_XO {

        // All loads with an index register. The non-update versions
        // all use the value 0 if Ra == R0, not the value contained in
        // R0. Others update Ra with the effective address. In all cases,
        // Ra and Rb are source registers, Rt is the destintation.
        format LoadIndexOp {
            87: lbzx({{ Rt = Mem_ub; }});
            279: lhzx({{ Rt = Mem_uh; }});
            343: lhax({{ Rt = Mem_sh; }});
            790: lhbrx({{ Rt = swap_byte(Mem_uh); }});
            23: lwzx({{ Rt = Mem_uw; }});
            341: lwax({{ Rt = Mem_sw; }});
            20: lwarx({{ Rt = Mem_sw; Rsv = 1; RsvLen = 4; RsvAddr = EA; }});
            534: lwbrx({{ Rt = swap_byte(Mem_uw); }});
            21: ldx({{ Rt = Mem; }});
            532: ldbrx({{ Rt = swap_byte(Mem); }});
            535: lfsx({{ Ft_sf = Mem_sf; }});
            599: lfdx({{ Ft = Mem_df; }});
            855: lfiwax({{ Ft_uw = Mem; }});
        }

        format LoadIndexUpdateOp {
            119: lbzux({{ Rt = Mem_ub; }});
            311: lhzux({{ Rt = Mem_uh; }});
            375: lhaux({{ Rt = Mem_sh; }});
            55: lwzux({{ Rt = Mem_uw; }});
            373: lwaux({{ Rt = Mem_sw; }});
            53: ldux({{ Rt = Mem; }});
            567: lfsux({{ Ft_sf = Mem_sf; }});
            631: lfdux({{ Ft = Mem_df; }});
        }

        format StoreIndexOp {
            215: stbx({{ Mem_ub = Rs_ub; }});
            407: sthx({{ Mem_uh = Rs_uh; }});
            918: sthbrx({{ Mem_uh = swap_byte(Rs_uh); }});
            151: stwx({{ Mem_uw = Rs_uw; }});
            150: stwcx({{
                bool store_performed = false;
                Mem_uw = Rs_uw;
                if (Rsv) {
                    if (RsvLen == 4) {
                        if (RsvAddr == EA) {
                            store_performed = true;
                        }
                    }
                }
                Xer xer = XER;
                Cr cr = CR;
                cr.cr0 = ((store_performed ? 0x2 : 0x0) | xer.so);
                CR = cr;
                Rsv = 0;
            }});
            662: stwbrx({{ Mem_uw = swap_byte(Rs_uw); }});
            149: stdx({{ Mem = Rs }});
            660: stdbrx({{ Mem = swap_byte(Rs); }});
            663: stfsx({{ Mem_sf = Fs_sf; }});
            727: stfdx({{ Mem_df = Fs; }});
            983: stfiwx({{ Mem = Fs_uw; }});
        }

        format StoreIndexUpdateOp {
            247: stbux({{ Mem_ub = Rs_ub; }});
            439: sthux({{ Mem_uh = Rs_uh; }});
            183: stwux({{ Mem_uw = Rs_uw; }});
            181: stdux({{ Mem = Rs; }});
            695: stfsux({{ Mem_sf = Fs_sf; }});
            759: stfdux({{ Mem_df = Fs; }});
        }

        format IntArithOp {
            779: modsw({{
                int64_t src1 = Ra_sw;
                int64_t src2 = Rb_sw;
                if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            267: moduw({{
                uint64_t src1 = Ra_uw;
                uint64_t src2 = Rb_uw;
                if (src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            777: modsd({{
                int64_t src1 = Ra_sd;
                int64_t src2 = Rb_sd;
                if ((src1 != INT64_MIN || src2 != -1) && src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});

            265: modud({{
                uint64_t src1 = Ra;
                uint64_t src2 = Rb;
                if (src2 != 0) {
                    Rt = src1 % src2;
                } else {
                    Rt = 0;
                }
            }});
        }

        format IntCompOp {
            0: cmp({{
                if (length) {
                    cr = makeCRField(Ra_sd, Rb_sd, xer.so);
                } else {
                    cr = makeCRField((int32_t)Ra_sd, (int32_t)Rb_sd, xer.so);
                }
            }});

            32: cmpl({{
                if (length) {
                    cr = makeCRField(Ra, Rb, xer.so);
                } else {
                    cr = makeCRField((uint32_t)Ra, (uint32_t)Rb, xer.so);
                }
            }});

            192: cmprb({{
                uint32_t src1 = Ra_ub;
                uint32_t src2 = Rb_uw;
                uint8_t src2lo = src2 & 0xff;
                uint8_t src2hi = (src2 >>= 8) & 0xff;
                uint32_t res = (src2lo <= src1) & (src1 <= src2hi);
                if (length) {
                    src2lo = (src2 >>= 8) & 0xff;
                    src2hi = (src2 >>= 8) & 0xff;
                    res = ((src2lo <= src1) & (src1 <= src2hi)) | res;
                }
                cr = res << 2;
            }});

            224: cmpeqb({{
                // The code below is based on the algorithm used to implement
                // the "cmpeqb" instruction for Power emulation in Qemu.
                const uint64_t m1 = 0x0101010101010101;
                const uint64_t m2 = 0x8080808080808080;
                uint64_t res = Rb ^ (Ra_ub * m1);
                res = (res - m1) & ~res & m2;
                cr = (res != 0) << 2;
            }});
        }

        // Generic integer format instructions.
        format IntOp {
            339: decode SPR {
                0x20: mfxer({{ Rt = XER; }});
                0x100: mflr({{ Rt = LR; }});
                0x120: mfctr({{ Rt = CTR; }});
            }
            467: decode SPR {
                0x20: mtxer({{ XER = Rs; }});
                0x100: mtlr({{ LR = Rs; }});
                0x120: mtctr({{ CTR = Rs; }});
            }
        }

        // Integer logic instructions use source registers Rs and Rb,
        // with destination register Ra.
        format IntLogicOp {
            28: and({{ Ra = Rs & Rb; }}, true);
            316: xor({{ Ra = Rs ^ Rb; }}, true);
            476: nand({{ Ra = ~(Rs & Rb); }}, true);
            444: or({{ Ra = Rs | Rb; }}, true);
            124: nor({{ Ra = ~(Rs | Rb); }}, true);
            60: andc({{ Ra = Rs & ~Rb; }}, true);
            284: eqv({{ Ra = ~(Rs ^ Rb); }}, true);
            412: orc({{ Ra = Rs | ~Rb; }}, true);
            954: extsb({{ Ra = Rs_sb; }}, true);
            922: extsh({{ Ra = Rs_sh; }}, true);
            986: extsw({{ Ra = Rs_sw; }}, true);
            26: cntlzw({{ Ra = findLeadingZeros(Rs_uw); }}, true);
            58: cntlzd({{ Ra = findLeadingZeros(Rs); }}, true);
            538: cnttzw({{ Ra = findTrailingZeros(Rs_uw); }}, true);
            570: cnttzd({{ Ra = findTrailingZeros(Rs); }}, true);

            508: cmpb({{
                uint64_t mask = 0xff;
                uint64_t res = 0;
                for (int i = 0; i < 8; ++i) {
                    if ((Rs & mask) == (Rb & mask)) {
                        res |= mask;
                    }
                    mask <<= 8;
                }
                Ra = res;
            }});

            122: popcntb({{
                // The code below is based on the algorithm used to implement
                // the "popcntb" instruction for Power emulation in Qemu.
                const uint64_t m1 = 0x5555555555555555ULL;
                const uint64_t m2 = 0x3333333333333333ULL;
                const uint64_t m4 = 0x0f0f0f0f0f0f0f0fULL;
                uint64_t res = Rs;
                res = (res & m1) + ((res >> 1) & m1);
                res = (res & m2) + ((res >> 2) & m2);
                res = (res & m4) + ((res >> 4) & m4);
                Ra = res;
            }});

            378: popcntw({{
                // The code below is based on the algorithm used to implement
                // the "popcntw" instruction for Power emulation in Qemu.
                const uint64_t m1 = 0x5555555555555555ULL;
                const uint64_t m2 = 0x3333333333333333ULL;
                const uint64_t m4 = 0x0f0f0f0f0f0f0f0fULL;
                const uint64_t m8 = 0x00ff00ff00ff00ffULL;
                const uint64_t m16 = 0x0000ffff0000ffffULL;
                uint64_t res = Rs;
                res = (res & m1) + ((res >> 1) & m1);
                res = (res & m2) + ((res >> 2) & m2);
                res = (res & m4) + ((res >> 4) & m4);
                res = (res & m8) + ((res >> 8) & m8);
                res = (res & m16) + ((res >> 16) & m16);
                Ra = res;
            }});

            506: popcntd({{ Ra = popCount(Rs); }});

            154: prtyw({{
                // The code below is based on the algorithm used to implement
                // the "prtyw" instruction for Power emulation in Qemu.
                uint64_t res = Rs;
                res = res ^ (res >> 16);
                res = res ^ (res >> 8);
                res = res & 0x100000001;
                Ra = res;
            }});

            186: prtyd({{
                // The code below is based on the algorithm used to implement
                // the "prtyd" instruction for Power emulation in Qemu.
                uint64_t res = Rs;
                res = res ^ (res >> 32);
                res = res ^ (res >> 16);
                res = res ^ (res >> 8);
                res = res & 0x1;
                Ra = res;
            }});

            252: bpermd({{
                uint64_t res = 0;
                for (int i = 0; i < 8; ++i) {
                    int index = (Rs >> (i * 8)) & 0xff;
                    if (index < 64) {
                        if (Rb & (1ULL << (63 - index))) {
                            res |= 1 << i;
                        }
                    }
                }
                Ra = res;
            }});
        }

        // Integer instructions with a shift value.
        format IntShiftOp {
            24: slw({{
                int32_t shift = Rb_sw;
                uint32_t res = Rs_uw & ~((shift << 26) >> 31);
                if (shift != 0) {
                    shift = shift & 0x1f;
                    res = res << shift;
                }
                Ra = res;
            }});

            536: srw({{
                int32_t shift = Rb_sw;
                uint32_t res = Rs_uw & ~((shift << 26) >> 31);
                if (shift != 0) {
                    shift = shift & 0x1f;
                    res = res >> shift;
                }
                Ra = res;
            }});

            792: sraw({{
                int32_t src = Rs_sw;
                uint32_t shift = Rb_uw;
                int64_t res;
                if ((shift & 0x20) != 0) {
                    res = src >> 31;
                    if (res != 0) {
                        setCA = true;
                    }
                } else {
                    if (shift != 0) {
                        shift = shift & 0x1f;
                        res = src >> shift;
                        if (src < 0 && (src & mask(shift)) != 0) {
                            setCA = true;
                        }
                    } else {
                        res = src;
                    }
                }
                Ra = res;
            }},
            true);

            824: srawi({{
                int32_t src = Rs_sw;
                int64_t res;
                if (shift != 0) {
                    res = src >> shift;
                    if (src < 0 && (src & mask(shift)) != 0) {
                        setCA = true;
                    }
                } else {
                    res = src;
                }
                Ra = res;
            }},
            true);
        }

        format IntConcatShiftOp {
            27: sld({{
                int64_t shift = Rb_sd;
                uint64_t res = Rs & ~((shift << 57) >> 63);
                if (shift != 0) {
                    shift = shift & 0x3f;
                    res = res << shift;
                }
                Ra = res;
            }});

            539: srd({{
                int64_t shift = Rb_sd;
                uint64_t res = Rs & ~((shift << 57) >> 63);
                if (shift != 0) {
                    shift = shift & 0x3f;
                    res = res >> shift;
                }
                Ra = res;
            }});

            794: srad({{
                int64_t src = Rs_sd;
                uint64_t shift = Rb;
                int64_t res;
                if ((shift & 0x40) != 0) {
                    res = src >> 63;
                    if (res != 0) {
                        setCA = true;
                    }
                } else {
                    if (shift != 0) {
                        shift = shift & 0x3f;
                        res = src >> shift;
                        if (src < 0 && (src & mask(shift)) != 0) {
                            setCA = true;
                        }
                    } else {
                        res = src;
                    }
                }
                Ra = res;
            }},
            true);
        }

        // These instructions all provide data cache hints
        format MiscOp {
            278: dcbt({{ }});
            246: dcbtst({{ }});
            598: sync({{ }}, [ IsMemBarrier ]);
            854: eieio({{ }}, [ IsMemBarrier ]);
        }

        // These instructions are of XO form with bit 21 as the OE bit.
        default: decode XO_XO {

            // These instructions can all be reduced to the form
            // Rt = src1 + src2 [+ CA], therefore we just give src1 and
            // src2 (and, if necessary, CA) definitions and let the python
            // script deal with setting things up correctly. We also give
            // flags to say which control registers to set.
            format IntSumOp {
                266: add({{ Ra }}, {{ Rb }});
                40: subf({{ ~Ra }}, {{ Rb }}, {{ 1 }});
                10: addc({{ Ra }}, {{ Rb }},
                         computeCA = true);
                8: subfc({{ ~Ra }}, {{ Rb }}, {{ 1 }},
                         true);
                104: neg({{ ~Ra }}, {{ 1 }});
                138: adde({{ Ra }}, {{ Rb }}, {{ xer.ca }},
                          true);
                234: addme({{ Ra }}, {{ -1ULL }}, {{ xer.ca }},
                           true);
                136: subfe({{ ~Ra }}, {{ Rb }}, {{ xer.ca }},
                           true);
                232: subfme({{ ~Ra }}, {{ -1ULL }}, {{ xer.ca }},
                            true);
                202: addze({{ Ra }}, {{ xer.ca }},
                           computeCA = true);
                200: subfze({{ ~Ra }}, {{ xer.ca }},
                            computeCA = true);
            }

            // Arithmetic instructions all use source registers Ra and Rb,
            // with destination register Rt.
            format IntArithCheckRcOp {
                75: mulhw({{
                    uint64_t res = (int64_t)Ra_sw * Rb_sw;
                    res = res >> 32;
                    Rt = res;
                }});

                11: mulhwu({{
                    uint64_t res = (uint64_t)Ra_uw * Rb_uw;
                    res = res >> 32;
                    Rt = res;
                }});

                235: mullw({{
                    int64_t res = (int64_t)Ra_sw * Rb_sw;
                    if (res != (int32_t)res) {
                        setOV = true;
                    }
                    Rt = res;
                }},
                true);

                73: mulhd({{
                    int64_t res;
                    std::tie(std::ignore, res) = multiply(Ra_sd, Rb_sd);
                    Rt = res;
                }});

                9: mulhdu({{
                    uint64_t res;
                    std::tie(std::ignore, res) = multiply(Ra, Rb);
                    Rt = res;
                }});

                233: mulld({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    uint64_t res = src1 * src2;
                    std::tie(res, std::ignore) = multiply(src1, src2);
                    if (src1 != 0 && (int64_t)res / src1 != src2) {
                        setOV = true;
                    }
                    Rt = res;
                }},
                true);

                491: divw({{
                    int32_t src1 = Ra_sw;
                    int32_t src2 = Rb_sw;
                    if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                        Rt = (uint32_t)(src1 / src2);
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                459: divwu({{
                    uint32_t src1 = Ra_uw;
                    uint32_t src2 = Rb_uw;
                    if (src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                427: divwe({{
                    int32_t src1 = Ra_sw;
                    int32_t src2 = Rb_sw;
                    int64_t res;
                    if ((src1 != INT32_MIN || src2 != -1) && src2 != 0) {
                        res = ((int64_t)src1 << 32) / src2;
                        if (res == (int32_t)res) {
                            Rt = (uint32_t)res;
                        } else {
                            Rt = 0;
                            setOV = true;
                        }
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                395: divweu({{
                    uint32_t src1 = Ra_ud;
                    uint32_t src2 = Rb_ud;
                    uint64_t res;
                    if (src2 != 0) {
                        res = ((uint64_t)src1 << 32) / src2;
                        if (res <= UINT32_MAX) {
                            Rt = (uint32_t)res;
                        } else {
                            Rt = 0;
                            setOV = true;
                        }
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                489: divd({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    if ((src1 != INT64_MIN || src2 != -1) && src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                457: divdu({{
                    uint64_t src1 = Ra;
                    uint64_t src2 = Rb;
                    if (src2 != 0) {
                        Rt = src1 / src2;
                    } else {
                        Rt = 0;
                        setOV = true;
                    }
                }},
                true);

                425: divde({{
                    int64_t src1 = Ra_sd;
                    int64_t src2 = Rb_sd;
                    int64_t res;
                    std::tie(setOV, res, std::ignore) = divide(0, src1, src2);
                    if (!setOV) {
                        Rt = res;
                    } else {
                        Rt = 0;
                    }
                }},
                true);

                393: divdeu({{
                    uint64_t src1 = Ra;
                    uint64_t src2 = Rb;
                    uint64_t res;
                    std::tie(setOV, res, std::ignore) = divide(0, src1, src2);
                    if (!setOV) {
                        Rt = res;
                    } else {
                        Rt = 0;
                    }
                }},
                true);
            }

            // These instructions are of XS form and use bits 21 - 29 as XO.
            default: decode XS_XO {
                format IntConcatShiftOp {
                    413: sradi({{
                        int64_t src = Rs_sd;
                        if (shift != 0) {
                            Ra = src >> shift;
                            if (src < 0 && (src & mask(shift))) {
                                setCA = true;
                            }
                        } else {
                            Ra = src;
                        }
                    }},
                    true);

                    445: extswsli({{
                        int64_t src = Rs_sw;
                        if (shift != 0) {
                            Ra = src << shift;
                        } else {
                            Ra = src;
                        }
                    }});
                }

                default: decode XFX_XO {
                    format IntOp {
                        144: mtcrf({{
                            uint32_t mask = 0;
                            for (int i = 0; i < 8; ++i) {
                                if (((FXM >> i) & 0x1) == 0x1) {
                                    mask |= 0xf << (4 * i);
                                }
                            }
                            CR = (Rs & mask) | (CR & ~mask);
                        }});
                        19: mfcr({{ Rt = CR; }});
                    }
                }
            }
        }
    }

    format LoadDispOp {
        34: lbz({{ Rt = Mem_ub; }});
        40: lhz({{ Rt = Mem_uh; }});
        42: lha({{ Rt = Mem_sh; }});
        32: lwz({{ Rt = Mem_uw; }});
        48: lfs({{ Ft_sf = Mem_sf; }});
        50: lfd({{ Ft = Mem_df; }});
    }

    format LoadDispUpdateOp {
        35: lbzu({{ Rt = Mem_ub; }});
        41: lhzu({{ Rt = Mem_uh; }});
        43: lhau({{ Rt = Mem_sh; }});
        33: lwzu({{ Rt = Mem_uw; }});
        49: lfsu({{ Ft_sf = Mem_sf; }});
        51: lfdu({{ Ft = Mem_df; }});
    }

    format StoreDispOp {
        38: stb({{ Mem_ub = Rs_ub; }});
        44: sth({{ Mem_uh = Rs_uh; }});
        36: stw({{ Mem_uw = Rs_uw; }});
        52: stfs({{ Mem_sf = Fs_sf; }});
        54: stfd({{ Mem_df = Fs; }});
    }

    format StoreDispUpdateOp {
        39: stbu({{ Mem_ub = Rs_ub; }});
        45: sthu({{ Mem_uh = Rs_uh; }});
        37: stwu({{ Mem_uw = Rs_uw; }});
        53: stfsu({{ Mem_sf = Fs_sf; }});
        55: stfdu({{ Mem_df = Fs; }});
    }

    58: decode DS_XO {
        format LoadDispShiftOp {
            2: lwa({{ Rt = Mem_sw; }});
            0: ld({{ Rt = Mem; }});
        }

        format LoadDispShiftUpdateOp {
            1: ldu({{ Rt = Mem; }});
        }
    }

    62: decode DS_XO {
        format StoreDispShiftOp {
            0: std({{ Mem = Rs; }});
        }

        format StoreDispShiftUpdateOp {
            1: stdu({{ Mem = Rs; }});
        }
    }

    format IntImmArithCheckRaOp {
        14: addi({{ Rt = Ra + simm; }},
                 {{ Rt = simm }});
        15: addis({{ Rt = Ra + (simm << 16); }},
                  {{ Rt = simm << 16; }});
    }

    format IntImmArithOp {
        12: addic({{
            uint64_t src = Ra;
            Rt = src + simm;
        }},
        true);

        13: addic_({{
            uint64_t src = Ra;
            Rt = src + simm;
        }},
        true, true);

        8: subfic({{
            uint64_t src = ~Ra;
            Rt = src + simm + 1;
        }},
        true);

        7: mulli({{
            int64_t res = Ra_sd * simm;
            Rt = res;
        }});
    }

    4: decode VA_XO {

        // Arithmetic instructions that use source registers Ra, Rb and Rc,
        // with destination register Rt.
        format IntArithOp {
            48: maddhd({{
                int64_t res;
                std::tie(std::ignore, res) = multiplyAdd(Ra_sd, Rb_sd, Rc_sd);
                Rt = res;
            }});

            49: maddhdu({{
                uint64_t res;
                std::tie(std::ignore, res) = multiplyAdd(Ra, Rb, Rc);
                Rt = res;
            }});

            51: maddld({{
                uint64_t res;
                std::tie(res, std::ignore) = multiplyAdd(Ra_sd, Rb_sd, Rc_sd);
                Rt = res;
            }});
        }
    }

    format IntImmCompOp {
        11: cmpi({{
            if (length) {
                cr = makeCRField(Ra_sd, simm, xer.so);
            } else {
                cr = makeCRField((int32_t)Ra_sd, simm, xer.so);
            }
        }});
    }

    format IntImmCompLogicOp {
        10: cmpli({{
            if (length) {
                cr = makeCRField(Ra, uimm, xer.so);
            } else {
                cr = makeCRField((uint32_t)Ra, uimm, xer.so);
            }
        }});
     }

    format IntImmLogicOp {
        24: ori({{ Ra = Rs | uimm; }});
        25: oris({{ Ra = Rs | (uimm << 16); }});
        26: xori({{ Ra = Rs ^ uimm; }});
        27: xoris({{ Ra = Rs ^ (uimm << 16); }});
        28: andi_({{ Ra = Rs & uimm; }},
                  true);
        29: andis_({{ Ra = Rs & (uimm << 16); }},
                   true);
    }

    format IntRotateOp {
        21: rlwinm({{
            uint64_t res;
            res = rotate(Rs, shift);
            res = res & bitmask(maskBeg, maskEnd);
            Ra = res;
        }});

        23: rlwnm({{
            uint64_t res;
            res = rotate(Rs, Rb);
            res = res & bitmask(maskBeg, maskEnd);
            Ra = res;
        }});

        20: rlwimi({{
            uint64_t res, mask;
            mask = bitmask(maskBeg, maskEnd);
            res = rotate(Rs, shift);
            res = (res & mask) | (Ra & ~mask);
            Ra = res;
        }});
    }

    // These instructions are of MD form and use bits 27 - 29 as XO.
    30: decode MD_XO {
        format IntConcatRotateOp {
            0: rldicl({{
                uint64_t res;
                if (shift != 0) {
                    res = rotate(Rs, shift);
                } else {
                    res = Rs;
                }
                res = res & bitmask(maskBeg, 63);
                Ra = res;
            }});

            1: rldicr({{
                uint64_t res;
                if (shift != 0) {
                    res = rotate(Rs, shift);
                } else {
                    res = Rs;
                }
                res = res & bitmask(0, maskEnd);
                Ra = res;
            }});

            2: rldic({{
                uint64_t res;
                if (shift != 0) {
                    res = rotate(Rs, shift);
                } else {
                    res = Rs;
                }
                res = res & bitmask(maskBeg, ~shift);
                Ra = res;
            }});

            3: rldimi({{
                uint64_t res, mask;
                mask = bitmask(maskBeg, ~shift);
                if (shift != 0) {
                    res = rotate(Rs, shift);
                } else {
                    res = Rs;
                }
                res = res & mask;
                res = res | (Ra & ~mask);
                Ra = res;
            }});

            // These instructions are of MDS form and use bits 27 - 30 as XO.
            default: decode MDS_XO {
                8: rldcl({{
                    uint64_t res;
                    uint32_t shift = Rb & 0x3f;
                    if (shift != 0) {
                        res = rotate(Rs, shift);
                    } else {
                        res = Rs;
                    }
                    res = res & bitmask(maskBeg, 63);
                    Ra = res;
                }});

                9: rldcr({{
                    uint64_t res;
                    uint32_t shift = Rb & 0x3f;
                    if (shift != 0) {
                        res = rotate(Rs, shift);
                    } else {
                        res = Rs;
                    }
                    res = res & bitmask(0, maskEnd);
                    Ra = res;
                }});
            }
        }
    }

    59: decode A_XO {
        format FloatArithOp {
            21: fadds({{ Ft = Fa + Fb; }});
            20: fsubs({{ Ft = Fa - Fb; }});
            25: fmuls({{ Ft = Fa * Fc; }});
            18: fdivs({{ Ft = Fa / Fb; }});
            29: fmadds({{ Ft = (Fa * Fc) + Fb; }});
            28: fmsubs({{ Ft = (Fa * Fc) - Fb; }});
            31: fnmadds({{ Ft = -((Fa * Fc) + Fb); }});
            30: fnmsubs({{ Ft = -((Fa * Fc) - Fb); }});
        }
    }

    // Since all these instructions have the same PO of 63, decode blocks
    // for different instruction forms are nested using default cases as
    // described above for instructions with PO of 31.
    63: decode A_XO {
        format FloatArithOp {
            21: fadd({{ Ft = Fa + Fb; }});
            20: fsub({{ Ft = Fa - Fb; }});
            25: fmul({{ Ft = Fa * Fc; }});
            18: fdiv({{ Ft = Fa / Fb; }});
            29: fmadd({{ Ft = (Fa * Fc) + Fb; }});
            28: fmsub({{ Ft = (Fa * Fc) - Fb; }});
            31: fnmadd({{ Ft = -((Fa * Fc) + Fb); }});
            30: fnmsub({{ Ft = -((Fa * Fc) - Fb); }});
        }

        default: decode X_XO {
            format FloatConvertOp {
                12: frsp({{ Ft_sf = Fb; }});
                15: fctiwz({{ Ft_sw = (int32_t)trunc(Fb); }});
            }

            format FloatOp {
              0: fcmpu({{
                  uint32_t c = makeCRField(Fa, Fb);
                  Fpscr fpscr = FPSCR;
                  fpscr.fprf.fpcc = c;
                  FPSCR = fpscr;
                  CR = insertCRField(CR, BF, c);
              }});
            }

            format FloatRCCheckOp {
                72: fmr({{ Ft = Fb; }});
                264: fabs({{
                    Ft_ud = Fb_ud;
                    Ft_ud = insertBits(Ft_ud, 63, 0); }});
                136: fnabs({{
                    Ft_ud = Fb_ud;
                    Ft_ud = insertBits(Ft_ud, 63, 1); }});
                40: fneg({{ Ft = -Fb; }});
                8: fcpsgn({{
                    Ft_ud = Fb_ud;
                    Ft_ud = insertBits(Ft_ud, 63, Fa_ud<63:63>);
                }});
                583: mffs({{ Ft_ud = FPSCR; }});
                134: mtfsfi({{
                    FPSCR = insertCRField(FPSCR, BF + (8 * (1 - W_FIELD)),
                                          U_FIELD);
                }});
                70: mtfsb0({{ FPSCR = insertBits(FPSCR, 31 - BT, 0); }});
                38: mtfsb1({{ FPSCR = insertBits(FPSCR, 31 - BT, 1); }});

                default: decode XFL_XO {
                    711: mtfsf({{
                        if (L_FIELD == 1) { FPSCR = Fb_ud; }
                        else {
                            for (int i = 0; i < 8; ++i) {
                                if (bits(FLM, i) == 1) {
                                    int k = 4 * (i + (8 * (1 - W_FIELD)));
                                    FPSCR = insertBits(FPSCR, k, k + 3,
                                                       bits(Fb_ud, k, k + 3));
                                }
                            }
                        }
                    }});
                }
            }
        }
    }
}
